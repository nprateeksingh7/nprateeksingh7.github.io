[
  {
    "id": "binarysearch",
    "title": "Binary Search",
    "category": "Searching",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "description": "Binary Search is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array.",
    "tags": ["search", "logarithmic", "divide and conquer"],
    "codeJava": "class Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) low = mid + 1;\n            else high = mid - 1;\n        }\n        return -1;\n    }\n}",
    "codeCpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) low = mid + 1;\n            else high = mid - 1;\n        }\n        return -1;\n    }\n};"
  },
  {
    "id": "dnf",
    "title": "Dutch National Flag Algorithm",
    "category": "Sorting",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "description": "Also known as the 'Sort Colors' problem. It sorts an array containing 0s, 1s, and 2s in a single pass using three pointers (low, mid, high).",
    "tags": ["sort", "colors", "0 1 2", "array", "two pointers"],
    "codeJava": "public void sortColors(int[] nums) {\n    int low = 0, mid = 0, high = nums.length - 1;\n    while (mid <= high) {\n        if (nums[mid] == 0) {\n            swap(nums, low, mid);\n            low++; mid++;\n        } else if (nums[mid] == 1) {\n            mid++;\n        } else {\n            swap(nums, mid, high);\n            high--;\n        }\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    "codeCpp": "void sortColors(vector<int>& nums) {\n    int low = 0, mid = 0, high = nums.size() - 1;\n    while (mid <= high) {\n        if (nums[mid] == 0) {\n            swap(nums[low], nums[mid]);\n            low++; mid++;\n        } else if (nums[mid] == 1) {\n            mid++;\n        } else {\n            swap(nums[mid], nums[high]);\n            high--;\n        }\n    }\n}"
  },
  {
    "id": "kadanes",
    "title": "Kadane's Algorithm",
    "category": "Arrays",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "description": "Used to find the maximum sum subarray in an array. It iterates through the array while maintaining the current sum and maximum sum found so far.",
    "tags": ["dynamic programming", "maximum subarray", "sum"],
    "codeJava": "public int maxSubArray(int[] nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        currentSum = Math.max(nums[i], currentSum + nums[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    return maxSum;\n}",
    "codeCpp": "int maxSubArray(vector<int>& nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n        currentSum = max(nums[i], currentSum + nums[i]);\n        maxSum = max(maxSum, currentSum);\n    }\n    return maxSum;\n}"
  },
  {
    "id": "voting_algo",
    "title": "Boyer-Moore Voting Algorithm",
    "category": "Arrays",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "description": "An optimal algorithm to find the majority element (element appearing more than n/2 times) in an array.",
    "tags": ["majority element", "voting", "array"],
    "codeJava": "public int majorityElement(int[] nums) {\n    int count = 0;\n    Integer candidate = null;\n    for (int num : nums) {\n        if (count == 0) candidate = num;\n        count += (num == candidate) ? 1 : -1;\n    }\n    return candidate;\n}",
    "codeCpp": "int majorityElement(vector<int>& nums) {\n    int count = 0;\n    int candidate = 0;\n    for (int num : nums) {\n        if (count == 0) candidate = num;\n        count += (num == candidate) ? 1 : -1;\n    }\n    return candidate;\n}"
  },
  {
    "id": "dijkstra",
    "title": "Dijkstra Algorithm",
    "category": "Graphs",
    "timeComplexity": "O((V + E) log V)",
    "spaceComplexity": "O(V)",
    "description": "Dijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative weights.",
    "tags": ["graph", "shortest path", "greedy"],
    "codeJava": "import java.util.*;\nclass Solution {\n    static class Pair {\n        int v, wt;\n        Pair(int v, int wt) { this.v = v; this.wt = wt; }\n    }\n    public int[] dijkstra(int V, ArrayList<ArrayList<Pair>> adj, int src) {\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->a.wt-b.wt);\n        int[] dist = new int[V];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[src] = 0;\n        pq.add(new Pair(src, 0));\n        while(!pq.isEmpty()) {\n            Pair cur = pq.poll();\n            for(Pair p : adj.get(cur.v)) {\n                if(dist[p.v] > cur.wt + p.wt) {\n                    dist[p.v] = cur.wt + p.wt;\n                    pq.add(new Pair(p.v, dist[p.v]));\n                }\n            }\n        }\n        return dist;\n    }\n}",
    "codeCpp": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dijkstra(int V, vector<vector<pair<int,int>>>& adj, int src) {\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\n    vector<int> dist(V, INT_MAX);\n    dist[src] = 0;\n    pq.push({0, src});\n    while(!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        for(auto [v, w] : adj[u]) {\n            if(dist[v] > d + w) {\n                dist[v] = d + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}"
  },
  {
    "id": "reverse_integer",
    "title": "Reverse Integer",
    "category": "Math",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "description": "Reverses digits of a 32-bit signed integer while handling overflow.",
    "tags": ["math", "reverse", "integer"],
    "codeJava": "public int reverse(int x) {\n    int rev = 0;\n    while (x != 0) {\n        int d = x % 10;\n        x /= 10;\n        if (rev > Integer.MAX_VALUE/10 || rev < Integer.MIN_VALUE/10) return 0;\n        rev = rev * 10 + d;\n    }\n    return rev;\n}",
    "codeCpp": "int reverse(int x) {\n    long rev = 0;\n    while(x != 0) {\n        rev = rev * 10 + x % 10;\n        x /= 10;\n    }\n    return (rev > INT_MAX || rev < INT_MIN) ? 0 : rev;\n}"
  },
  {
    "id": "palindrome_number",
    "title": "Palindrome Number",
    "category": "Math",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "description": "Checks whether an integer is a palindrome.",
    "tags": ["math", "palindrome"],
    "codeJava": "public boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int rev = 0, temp = x;\n    while (temp != 0) {\n        rev = rev * 10 + temp % 10;\n        temp /= 10;\n    }\n    return rev == x;\n}",
    "codeCpp": "bool isPalindrome(int x) {\n    if(x < 0) return false;\n    int rev = 0, t = x;\n    while(t) {\n        rev = rev * 10 + t % 10;\n        t /= 10;\n    }\n    return rev == x;\n}"
  },
  {
    "id": "sieve_of_eratosthenes",
    "title": "Sieve of Eratosthenes",
    "category": "Math",
    "timeComplexity": "O(n log log n)",
    "spaceComplexity": "O(n)",
    "description": "Efficient algorithm to find all prime numbers up to n.",
    "tags": ["prime", "math", "sieve"],
    "codeJava": "public void sieve(int n) {\n    boolean[] prime = new boolean[n+1];\n    Arrays.fill(prime, true);\n    prime[0] = prime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n        if (prime[i]) {\n            for (int j = i * i; j <= n; j += i)\n                prime[j] = false;\n        }\n    }\n}",
    "codeCpp": "void sieve(int n) {\n    vector<bool> prime(n+1, true);\n    prime[0] = prime[1] = false;\n    for(int i = 2; i*i <= n; i++) {\n        if(prime[i]) {\n            for(int j = i*i; j <= n; j += i)\n                prime[j] = false;\n        }\n    }\n}"
  },
  {
    "id": "gcd_lcm",
    "title": "GCD and LCM (Euclidean Algorithm)",
    "category": "Math",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "description": "Finds GCD using Euclidean algorithm and LCM using formula.",
    "tags": ["math", "gcd", "lcm"],
    "codeJava": "int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\nint lcm(int a, int b) {\n    return (a * b) / gcd(a, b);\n}",
    "codeCpp": "int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\nint lcm(int a, int b) {\n    return (a / gcd(a, b)) * b;\n}"
  },
  {
    "id": "bubble_sort",
    "title": "Bubble Sort",
    "category": "Sorting",
    "timeComplexity": "O(n^2)",
    "spaceComplexity": "O(1)",
    "description": "A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
    "tags": ["sorting", "simple", "comparison"],
    "codeJava": "void bubbleSort(int arr[]) {\n    int n = arr.length;\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n}",
    "codeCpp": "void bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++)\n        for (int j = 0; j < n-i-1; j++)\n            if (arr[j] > arr[j+1])\n                swap(arr[j], arr[j+1]);\n}"
  },
  {
    "id": "insertion_sort",
    "title": "Insertion Sort",
    "category": "Sorting",
    "timeComplexity": "O(n^2)",
    "spaceComplexity": "O(1)",
    "description": "Insertion Sort builds the sorted array one element at a time by inserting elements into their correct position.",
    "tags": ["sorting", "comparison", "array"],
    "codeJava": "void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}",
    "codeCpp": "void insertionSort(vector<int>& arr) {\n    for (int i = 1; i < arr.size(); i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}"
  },
  {
    "id": "selection_sort",
    "title": "Selection Sort",
    "category": "Sorting",
    "timeComplexity": "O(n^2)",
    "spaceComplexity": "O(1)",
    "description": "Selection Sort repeatedly selects the minimum element from the unsorted portion and places it at the beginning.",
    "tags": ["sorting", "array"],
    "codeJava": "void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIdx]) minIdx = j;\n        }\n        int temp = arr[minIdx];\n        arr[minIdx] = arr[i];\n        arr[i] = temp;\n    }\n}",
    "codeCpp": "void selectionSort(vector<int>& arr) {\n    for (int i = 0; i < arr.size() - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (arr[j] < arr[minIdx]) minIdx = j;\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}"
  },
  {
    "id": "matrix_transpose",
    "title": "Matrix Transpose",
    "category": "Matrix",
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)",
    "description": "Transpose of a matrix is obtained by converting rows into columns.",
    "tags": ["matrix", "2d array"],
    "codeJava": "void transpose(int[][] mat) {\n    int n = mat.length;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int temp = mat[i][j];\n            mat[i][j] = mat[j][i];\n            mat[j][i] = temp;\n        }\n    }\n}",
    "codeCpp": "void transpose(vector<vector<int>>& mat) {\n    int n = mat.size();\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            swap(mat[i][j], mat[j][i]);\n        }\n    }\n}"
  },
  {
    "id": "valid_parentheses",
    "title": "Valid Parentheses",
    "category": "Stack",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "description": "Checks whether a string of brackets is valid using stack.",
    "tags": ["stack", "string"],
    "codeJava": "boolean isValid(String s) {\n    Stack<Character> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') st.push(c);\n        else {\n            if (st.isEmpty()) return false;\n            char top = st.pop();\n            if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) return false;\n        }\n    }\n    return st.isEmpty();\n}",
    "codeCpp": "bool isValid(string s) {\n    stack<char> st;\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') st.push(c);\n        else {\n            if (st.empty()) return false;\n            char t = st.top(); st.pop();\n            if ((c == ')' && t != '(') || (c == '}' && t != '{') || (c == ']' && t != '[')) return false;\n        }\n    }\n    return st.empty();\n}"
  }
]